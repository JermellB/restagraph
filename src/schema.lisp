;   Copyright 2017 James Fleming <james@electronic-quill.net>
;
;   Licensed under the GNU General Public License
;   - for details, see LICENSE.txt in the top-level directory


;;;; Schema creation functions

(in-package #:restagraph)

(declaim (optimize (compilation-speed 0)
                   (speed 2)
                   (safety 3)
                   (debug 3)))


;;; Generic methods

(defgeneric set-relationships (obj rels)
  (:documentation "Set the value of the relationships slot in an incoming-subschema-version instance.
                   The value must be a list of incoming-rels instances."))

(defgeneric set-attributes (rtype attributes)
  (:documentation "Set the value of the attributes slot in an incoming-rtypes instance.
                   The value must be a list of incoming-rtype-attrs instances."))

(defgeneric set-resourcetypes (subschema rtypes)
  (:documentation "Set the value of the resourcetypes slot in an incoming-subschema-version instance.
                   The value must be a list of incoming-rtypes instances."))

(defgeneric get-relationship (schema source-type relationship dest-type)
  (:documentation "Extract the attributes of interest for a given relationship.
                  Return a 'relationship-attrs struct.
                  cardinality defaults to many:many."))

(defgeneric relationship-in-struct-p (rtype rel-type target-rtype)
  (:documentation "Check for a named type of relationship from a resourcetype to a target resourcetype.
  Return a schema-rels struct if present, otherwise nil.
  Note that it returns a list, which will have more than one element if we screwed up and allowed two
  relationships of the same type to the same target."))

(defgeneric dependent-resource-p (db resourcetype)
  (:documentation "Determine whether a resource-type is dependent or first-class"))

(defgeneric dependent-relationship-p (db source-type relationship dest-type)
  (:documentation "Determine whether this relationship is a dependent one between these two resource-types."))

(defgeneric resourcetype-exists-p (db resourcetype)
  (:documentation "Verify whether we have a definition for a resourcetype by this name.
  Return a schema-rtypes struct."))

(defgeneric get-resource-attributes-from-db (db resourcetype)
  (:documentation "Extract the attributes from resource definitions from the database,
  and return them as a list of schema-rtype-attrs structs."))

(defgeneric get-resourcetype-names (db)
  (:documentation "Return the names of resourcetypes, as a list of strings."))

(defgeneric describe-resource-type (db resourcetype)
  (:documentation "Return the description of a resource-type, as an alist.
                   Entries include :name, :attributes and :dependent.
                   The :recursive key is a boolean indicating whether to recursively traverse all the
                   relationships from this resource-type.
                   The :resources-seen key is used internally to break loops when recursing."))

(defgeneric validate-resource-before-creating (db resourcetype params)
  (:documentation "Confirm whether the provided data is valid, before attempting to use it to create a resource.
  If the data is valid, return a list of attributes suitable for feeding to Neo4J.
  If not, raise a suitable error"))



;;; Structures and their methods

(defclass abstract-rtypes ()
  ((name :initarg :name
         :reader name
         :type string)
   (dependent :initarg :dependent
              :reader dependent
              :type boolean)
   (notes :initarg :notes
          :reader notes
          :type (or null string))
   (attributes :reader attributes
               :type (or null list)
               :initform nil))
  (:documentation "Parent class for resourcetype subclasses. Not to be instantiated directly."))


(defclass schema-rtypes (abstract-rtypes)
  ((relationships
     :initarg relationships
     :reader relationships
     :type list))
  (:documentation "Resource-type definition, normally generated by digesting a JSON document."))

(defmethod set-attributes ((rtype schema-rtypes) (attributes list))
  (if (every #'(lambda (attr) (typep attr 'schema-rtype-attrs))
             attributes)
      (setf (slot-value rtype 'attributes) attributes)))

(defmethod set-relationships ((obj schema-rtypes) (rels list))
  (if (every #'(lambda (rel) (typep rel 'schema-rels))
             rels)
      (setf (slot-value obj 'relationships) rels)
      (error "Invalid type for schema-rtypes relationships slot.")))

(defun make-schema-rtypes (&key name dependent notes attributes relationships)
  (declare (type string name)
           (type boolean dependent)
           (type (or null string) notes)
           (type (or null list) attributes relationships))
  "Constructor for schema-rtypes instances."
  (let ((rtype (make-instance 'schema-rtypes :name name
                              :dependent dependent
                              :notes notes)))
    (when attributes (set-attributes rtype attributes))
    (when relationships (set-relationships rtype relationships))
    ;; Return the instance we created
    rtype))


(defclass schema-rtype-attrs ()
  ((name :initarg :name
         :reader name
         :type string)
   (description :initarg :description
                :reader description
                :type (or null string))
   (attr-values :initarg :attr-values
                :reader attr-values
                :type (or null list)))
  (:documentation "Attributes of resource-types"))


(defun make-schema-rtype-attrs (&key name description attr-values)
  (declare (type string name)
           (type (or null string) description)
           (type list attr-values))
  "Constructor for schema-rtype-attrs instances."
  (if (or (null attr-values)
          (and (listp attr-values)
               (every #'stringp attr-values)))
      (make-instance 'schema-rtype-attrs :name name
                     :description description
                     :attr-values attr-values)
      (error ":values arg must be a list of strings.")))


(defclass schema-rels ()
  ((name :initarg :name
         :reader name
         :type string)
   (target-type :initarg :target-type
                :reader target-type
                :type schema-rtypes)
   (cardinality :initarg :cardinality
                :reader cardinality
                :type string)
   (dependent :initarg :dependent
              :reader dependent
              :type boolean
              :initform nil)
   (notes :initarg :notes
          :reader notes
          :type (or null string)
          :initform nil))
  (:documentation "Relationships between resourcetypes, for use in schema definitions."))

(defmethod make-schema-rels (&key name target-type cardinality dependent notes)
  (declare (type string name cardinality)
           (type schema-rtypes target-type)
           (type boolean dependent)
           (type (or null string) notes))
  "Constructor for schema-rels instances"
  (make-instance 'schema-rels :name name
                 :target-type target-type
                 :cardinality cardinality
                 :dependent dependent
                 :notes notes))


;; Incoming data, describing things _to be added to_ a schema

(defclass incoming-subschema-version ()
  ((name :initarg :name
         :reader name
         :type string
         :initform (error ":name parameter must be specified."))
   (resourcetypes :initarg :resourcetypes
                  :reader resourcetypes
                  :type (or null list)
                  :initform nil)
   (relationships :initarg :relationships
                  :reader relationships
                  :type (or null list)
                  :initform nil))
  (:documentation "Parent structure for a subschema definition. Used for installing a schema."))

(defmethod set-resourcetypes ((subschema incoming-subschema-version)
                              (rtypes list))
  (if (every #'(lambda (rtype) (typep rtype 'incoming-rtypes))
             rtypes)
      (setf (slot-value subschema 'resourcetypes) rtypes)))

(defmethod set-relationships ((obj incoming-subschema-version)
                              (rels list))
  (if (every #'(lambda (rtype) (typep rtype 'incoming-rels))
             rels)
      (setf (slot-value obj 'relationships) rels)))

(defun make-incoming-subschema-version (&key name resourcetypes relationships)
  (declare (type string name)
           (type list resourcetypes))
  "Constructor for incoming-subschema-version instances."
  (let ((subschema (make-instance 'incoming-subschema-version :name name)))
    (when resourcetypes
      (set-resourcetypes subschema resourcetypes))
    (when relationships
      (set-relationships subschema relationships))
    ;; Return the instance that we created and modified
    subschema))


(defclass incoming-rtypes (abstract-rtypes)
  ()
  (:documentation "Resource-type definition, normally generated by digesting a JSON document."))

(defmethod set-attributes ((rtype incoming-rtypes) (attributes list))
  (if (every #'(lambda (attr) (typep attr 'incoming-rtype-attrs))
             attributes)
      (setf (slot-value rtype 'attributes) attributes)))


(defun make-incoming-rtypes (&key name dependent notes attributes)
  "Constructor for incoming-rtypes class."
  (declare (type string name)
           (type boolean dependent)
           (type (or null string) notes)
           (type list attributes))
  (let ((instance (make-instance 'incoming-rtypes
                                 :name name
                                 :dependent dependent
                                 :notes notes)))
    (when attributes (set-attributes instance attributes))
    ;; Return the instance that we created and modified
    instance))


(defclass incoming-rtype-attrs ()
  ((name :initarg :name
         :reader name
         :type string
         :initform (error ":name parameter must be specified."))
   (description :initarg :description
                :reader description
                :type (or null string))
   (attr-values :initarg :attr-values
           :reader attr-values
           :type (or null list)))
  (:documentation "Attributes of _incoming_ resource-types."))

(defun make-incoming-rtype-attrs (&key name description attr-values)
  (declare (type string name)
           (type (or null string) description)
           (type (or null list) attr-values))
  (if (or (null attr-values)
          (and (listp attr-values)
               (every #'stringp attr-values)))
      (make-instance 'incoming-rtype-attrs
                     :name name
                     :description description
                     :attr-values attr-values)
      (error ":values arg must be a list of strings.")))


(defclass incoming-rels ()
  ((name :initarg :name
         :reader name
         :type string
         :initform (error ":name parameter must be specified."))
   (source-type :initarg :source-type
                :reader source-type
                :type string
                :initform (error ":source-type parameter must be specified."))
   (target-type :initarg :target-type
                :reader target-type
                :type string
                :initform (error ":target-type parameter must be specified"))
   (cardinality :initarg :cardinality
                :reader cardinality
                :type string)
   (dependent :initarg :dependent
              :reader dependent
              :type boolean)
   (notes :initarg :notes
          :reader notes
          :type (or null string)))
  (:default-initargs :cardinality "many:many")
  (:documentation "Relationships between resourcetypes, for use in updating schema definitions."))

(defun make-incoming-rels (&key name
                                source-type
                                target-type
                                (cardinality "many:many")
                                (dependent nil)
                                notes)
  "Constructor function for incoming-rels"
  (declare (type string name source-type target-type cardinality)
           (type (or null string) notes)
           (type boolean dependent))
  (unless (member cardinality '("many:many" "many:1" "1:many" "1:1") :test #'equal)
    (error "Cardinality argument is not valid."))
  (make-instance 'incoming-rels :name name
                 :source-type source-type
                 :target-type target-type
                 :cardinality cardinality
                 :dependent dependent
                 :notes notes))


;;; Structure methods

(defmethod get-relationship ((schema hash-table)
                             (source-type string)
                             (relationship string)
                             (dest-type string))
  (log-message
    :debug
    (format nil "Retrieving the relationship ~A from ~A to ~A, from a hash-table schema."
            relationship source-type dest-type))
  (relationship-in-struct-p
    (resourcetype-exists-p schema source-type)
    relationship
    dest-type))


(defmethod relationship-in-struct-p ((rtype schema-rtypes)
                                     (rel-type string)
                                     (target-rtype string))
  (log-message :debug (format nil "Checking resourcetype ~A for relationship ~A to type ~A (string)"
                              (name rtype) rel-type target-rtype))
  (remove-if-not #'(lambda (rel)
                     (and
                       (equal rel-type (name rel))
                       (equal target-rtype (name
                                             (target-type rel)))))
                 (relationships rtype)))

(defmethod relationship-in-struct-p ((rtype schema-rtypes)
                                     (rel-type string)
                                     (target-rtype schema-rtypes))
  (log-message :debug (format nil "Checking resourcetype ~A for relationship ~A to type ~A (rtype)"
                              (name rtype) rel-type (name target-rtype)))
  (remove-if-not #'(lambda (rel)
                     (and
                       (equal rel-type (name rel))
                       (equal (name target-rtype)
                              (name (target-type rel)))))
                 (relationships rtype)))


;;; Functions - schema creation

(defun make-schema-hash-table ()
  "Convenience function for repeatably creating the kind of hash-table we expect."
  (make-hash-table :test #'equal))

(defun ensure-uniqueness-constraint (server label attribute)
  "Ensure Neo4j has a uniqueness constraint on the specified attribute/label combination."
  (declare (type neo4cl:neo4j-rest-server server)
           (type string label)
           (type string attribute))
  (handler-case
    (neo4cl:neo4j-transaction
      server
      `((:STATEMENTS
          ((:STATEMENT
             . ,(format nil "CREATE CONSTRAINT ON (r:~A) ASSERT r.~A IS UNIQUE"
                        label attribute))))))
    ;; If this fails because we already did it, that's fine.
    (neo4cl:client-error
      (e)
      ;; If we already have this constraint, catch the error and move on.
      (if (and
            (equal "Schema" (neo4cl:category e))
            (equal "EquivalentSchemaRuleAlreadyExists" (neo4cl:title e)))
          nil
          ;; If anything else went wrong, log it and pass it on up the stack
          (progn
            (log-message :debug (format nil "Received error '~A.~A ~A'"
                                        (neo4cl:category e)
                                        (neo4cl:title e)
                                        (neo4cl:message e)))
            (return-database-error
              (format nil "~A.~A: ~A"
                      (neo4cl:category e)
                      (neo4cl:title e)
                      (neo4cl:message e))))))))



;;; Methods for querying the schema

(defmethod dependent-resource-p ((db hash-table) (resourcetype string))
  (let ((rtype (gethash resourcetype db)))
    (when rtype
      (dependent rtype))))


(defmethod dependent-relationship-p ((db hash-table)
                                     (source-type string)
                                     (relationship string)
                                     (dest-type string))
  (log-message :debug
               (format nil "Checking whether ~A is a valid dependent relationship from ~A to ~A"
                       relationship source-type dest-type))
  (let ((stype (gethash source-type db)))
    (log-message :debug (format nil "Fetched value ~A" (name stype)))
    (when source-type
      ;; Fetch _all_ the relationships by this name, to that target-type
      (let ((candidates (remove-if-not
                          #'(lambda (rel)
                              (and (equal relationship (name rel))
                                   (equal dest-type
                                          (name (target-type rel)))))
                          (relationships stype))))
        ;; If a non-null list resulted,
        ;; return the boolean indicating whether the first (and theoretically only) item
        ;; in that list is a dependent relationship.
        (when candidates
          (dependent (car candidates)))))))


(defmethod resourcetype-exists-p ((db hash-table)
                                  (resourcetype string))
  (log-message :debug
               (format nil "Checking for existence of resourcetype '~A'"
                       resourcetype))
  (gethash resourcetype db))


(defmethod get-resource-attributes-from-db ((db hash-table)
                                            (resourcetype string))
  (log-message :debug (format nil "Getting attributes for resourcetype '~A'" resourcetype))
  (let ((struct (gethash resourcetype db)))
    (when struct
      (attributes struct))))

(defmethod get-resourcetype-names ((db hash-table))
  (log-message :debug "Fetching resourcetype names.")
  (loop for key being the hash-keys in db collecting key))


(defmethod describe-resource-type ((db hash-table)
                                   (resourcetype string))
  (log-message :debug (format nil "Describing resource-type '~A'" resourcetype))
  ;; Confirm whether this resourcetype exists at all.
  ;; If it doesn't, automatically return NIL.
  (let ((node (resourcetype-exists-p db resourcetype)))
    (when node
      ;; Construct the return values
      `((:NAME . ,(name node))
        (:ATTRIBUTES . ,(sort
                          (mapcar
                            #'(lambda (s) `(("name" . ,(name s))
                                            ("description" . ,(description s))
                                            ("vals" . ,(values s))))
                            (attributes node))
                          #'string-lessp
                          :key #'caar))
        (:DEPENDENT . ,(if (dependent node) "true" "false"))
        (:NOTES . ,(or (notes node) ""))
        (:RELATIONSHIPS . ,(mapcar #'(lambda (rel)
                                       ;; Return an alist of the values, ready for rendering into Javascript
                                       `((:RELATIONSHIP . ,(name rel))
                                         (:DEPENDENT . ,(if (dependent rel) "true" "false"))
                                         (:CARDINALITY . ,(cardinality rel))
                                         (:NOTES . ,(or (notes rel) ""))
                                         (:RESOURCETYPE ,(name
                                                           (target-type rel)))))
                                   (relationships node)))))))


;; Helper function
(defun format-post-params-as-properties (params)
  "Take an alist, as returned by (tbnl:post-parameters*), and transform it into the kind of map
  that Neo4J expects in the :PROPERTIES section of a query."
  (declare (type (or null cons) params))
  (log-message :debug "Formatting a set of POST parameters for use as Neo4j properties.")
  (mapcar #'(lambda (param)
              (cons (intern (escape-neo4j (string-downcase (car param))) :keyword)
                    (if (stringp (cdr param))
                      (escape-neo4j (cdr param))
                      (cdr param))))
          params))

;; Helper function
(defun validate-attributes (requested defined &key (invalid '()) (badvalue '()))
  "Recursive helper function to validate the requested attributes against those defined for the resourcetype.
   Return a list of three lists:
   - invalid attributes (attributes whose name is not defined for this resourcetype)
   - attributes for which an invalid value was provided"
  (declare (type (or cons null) requested)  ; alist, where the car is the name and the cdr is the value
           (type (or cons null) defined)    ; Should have the outer layer of conses stripped
           (type (or cons null) invalid)
           (type (or cons null) badvalue))
  (log-message :debug (format nil "validate-attributes requested attrs: ~A" requested))
  (log-message :debug (format nil "validate-attributes defined attrs: ~A" defined))
  ;; Are we at the end of the list of requested attributes?
  (if (null requested)
      ;; If we are, return what's been accumulated
      (list invalid badvalue)
      ;; If not, check the attribute at the head of the list, then call this function on the rest.
      (validate-attributes
        ;; Rest of the list.
        (cdr requested)
        ;; Definitions, unchanged.
        defined
        ;; If this attribute is invalid, add it to that accumulator.
        ;; Pull the list of attribute-names from the 'defined parameter, and test whether it's a member.
        :invalid (if (not (member (caar requested)
                                  (mapcar #'(lambda (attr) (name attr))
                                          defined)
                                  :test #'equal))
                   ;; Invalid attribute. Log it and add it to the `invalid` accumulator.
                   (progn
                     (log-message :debug (format nil "Detected invalid attribute name '~A'" (caar requested)))
                     (append invalid (list (car requested))))
                   ;; It's valid; leave the `invalid` list as-is
                   invalid)
        :badvalue (if
                     ;; Is it a valid attribute? (yes, we have to test this again)
                     (if (member (caar requested)
                                 ;; Remember this was parsed from JSON
                                 (mapcar #'(lambda (attr) (name attr))
                                         defined)
                                 :test #'equal)
                         ;; Is this an enum attribute?
                         (let ((enums
                                 (attr-values
                                   (car (remove-if-not #'(lambda (attr)
                                                           (equal (caar requested)
                                                                  (name attr)))
                                                       defined)))))
                           (if (and enums
                                    (not (null enums)))
                               ;; If so, is it a valid value?
                               (when
                                 (member (cdar requested)
                                         enums
                                         :test #'equal)
                                 ;; If it's a valid value for this enum, return True
                                 t)
                               ;; If it's not an enum, then we do no other checking.
                               t))
                         ;; If it's not a valid attribute, this isn't relevant.
                         t)
                     ;; If all those tests passed, pass on the value of `badvalue` we received
                     badvalue
                     ;; If any of those failed, add this to `badvalue`
                     (append badvalue (list (car requested)))))))


;; This actually works as-is for both types, hence the funky approach of
;; not-specialising and then manually declaring types.
(defmethod validate-resource-before-creating ((db hash-table)
                                               (resourcetype string)
                                               ;; params is what Hunchentoot received via POST
                                               (params list))
  (log-message
    :debug
    (format nil "validate-resource-before-creating resourcetype ~A with params ~{~A~^, ~}"
            resourcetype params))
  ;; Does this resource-type exist?
  (if (resourcetype-exists-p db resourcetype)
    ;; Were attributes specified and, if so, are they all valid for this resource-type?
    (let
      ;; Exempt "uid" from validation
      ((requested-attributes
         (remove-if #'(lambda (param) (equal (car param) "uid"))
                    params))
       ;; Get the attributes defined for this resource-type
       (defined-attributes (get-resource-attributes-from-db db resourcetype))
       ;; Extract the original UID here, to reduce mess later
       (original-uid (or (cdr (assoc "uid" params :test #'string=)) "")))
      ;; Put this log message here to get it inside the let statement,
      ;; and thus avoid a progn.
      (log-message :debug (format nil "Confirmed: resourcetype '~A' exists" resourcetype))
      ;; Now validate the attributes and return the results.
      (log-message :debug "Checking the supplied attributes.")
      (let ((results (validate-attributes requested-attributes defined-attributes)))
        ;; Were the requested attributes all valid?
        (if (and (null (first results))
                 (null (second results)))
          ;; If so, return the supplied attributes to the caller, properly formatted for Neo4j.
          (let ((formatted-params
                  (format-post-params-as-properties
                    ;requested-attributes
                    (acons "uid" (sanitise-uid original-uid)
                           (acons "original_uid" original-uid
                                  (remove-if #'(lambda (param) (equal (car param) "uid"))
                                             params))))))
            (log-message :debug (format nil "Returning formatted parameters ~A" formatted-params))
            formatted-params)
          ;; If not, report the problem.
          (progn
            (when (first results)
              (log-message :debug (format nil "Identified invalid attribute-names: ~{~A~^, ~}"
                                          (first results))))
            (when (second results)
              (log-message :debug (format nil "Identified invalid values ~{~A~^, ~}"
                                          (second results))))
            (error 'restagraph:client-error :message
                   (format nil "Invalid attributes for ~A resources: ~{~A~^, ~}. Invalid values: ~{~A~^, ~}."
                           resourcetype (first results) (second results)))))))
    ;; No such resourcetype
    (signal 'client-error :message "No such resourcetype")))
